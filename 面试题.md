当然，这些都是非常经典的前端面试问题。我为你整理了一份清晰、准确的回答，你可以用它来准备面试。

---

### **二、框架与状态管理**

**2. 状态管理 Pinia，路由 vue-router**

* **Pinia**： 是 Vue.js 的官方推荐的状态管理库。它相比之前的 Vuex 更简单，具有完整的 TypeScript 支持，并且提供了 `state`、`getters`、`actions` 来集中管理组件的共享状态，解决了多层组件嵌套传值的繁琐问题。
* **vue-router**： 是 Vue.js 的官方路由管理器。它用于构建单页面应用，通过管理 URL 路径与组件的映射关系，实现页面间的无刷新跳转、动态路由、导航守卫等功能。

### **三、Vue 相关**

**3. v-if 和 v-show 的区别**

* **`v-if`**：是“真正的”条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。如果初始条件为假，则什么也不做，直到条件变为真时才开始渲染。**它会引起 DOM 元素的添加和移除**。
* **`v-show`**：不管初始条件是什么，元素总是会被渲染，只是简单地基于 CSS 的 `display` 属性进行切换。**它始终保留在 DOM 中，仅改变 `display: none/block`**。
* **使用场景**：`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 `v-show` 较好；如果在运行时条件很少改变，则使用 `v-if` 较好。

### **四、CSS 与渲染优化**

**4. 元素在视窗范围内不可见的方法**

1. `display: none`：元素不显示，并且不占据文档流空间。
2. `visibility: hidden`：元素不可见，但依然占据空间。
3. `opacity: 0`：元素完全透明，不可见，但依然可以触发事件（如点击）。
4. 通过 `position` 定位将其移出可视区域（如 `left: -9999px`）。
5. 使用 `clip-path: inset(100%)` 将其裁剪掉。

**5. visibility 和 opacity 两者有何区别**

* **`visibility: hidden`**：
  * 元素不可见，**但仍在文档流中占据空间**。
  * **不会响应绑定的事件**（如点击）。
  * 会引起重绘。
* **`opacity: 0`**：
  * 元素完全透明，不可见，**但仍在文档流中占据空间**。
  * **会响应绑定的事件**（如点击）。
  * 会创建一个新的图层，通常由 GPU 加速，性能较好。

**6. display: none 会引起页面重绘还是重排？**
**重排**。因为 `display: none` 会使元素从渲染树中完全消失，导致其自身及其所有子元素都不再占据空间，从而改变了页面的布局（几何属性），所以浏览器需要重新计算布局（重排），然后重新绘制。

**7. 你在开发一个页面时，有哪些方法可以减少重排和重绘？**

1. **集中改变样式**：使用 `classList` 或 `cssText` 一次性修改样式，而非频繁操作 `style`。
2. **使用 `transform` 和 `opacity` 来实现动画**：它们的变化由合成器处理，不会触发重排或重绘。
3. **避免使用表格布局**：表格的微小变化都会导致整个表格的重排。
4. **批量 DOM 操作**：使用文档片段 `DocumentFragment` 进行离线 DOM 操作，然后一次性添加到文档中。
5. **读写分离**：避免先读一个布局属性（如 offsetWidth），然后立即写一个属性，这会强制浏览器提前进行重排以提供最新值。应将读操作集中在一起。

### **五、路由与构建工具**

**8. 前端路由有哪几种方式**

* **Hash 模式**：利用 URL 中的 hash (`#`) 变化来实现路由。hash 变化不会导致浏览器向服务器发送请求。通过监听 `window.onhashchange` 事件。
* **History 模式**：利用 HTML5 History API (`pushState`, `replaceState`) 来修改 URL，而不刷新页面。需要服务器端配置支持，以避免直接访问子路径时返回 404。

**9. 导航守卫如何实现？**
在 vue-router 中，导航守卫主要通过路由实例上的钩子函数实现，用来在路由跳转前、跳转后或跳转过程中进行控制。

* **全局前置守卫**：`router.beforeEach((to, from, next) => { ... })`，常用于权限验证。
* **全局解析守卫**：`router.beforeResolve`
* **全局后置钩子**：`router.afterEach((to, from) => { ... })`，没有 `next` 参数，常用于分析、修改页面标题等。
* **路由独享的守卫**：在路由配置中直接定义 `beforeEnter`。
* **组件内的守卫**：在组件中定义 `beforeRouteEnter`、`beforeRouteUpdate`、`beforeRouteLeave`。

**10. Webpack 和 Vite 的区别，为什么 Vite 快？**

* **Webpack**：基于**打包器**的理念。在开发服务器启动前，需要先打包构建整个项目，生成 bundle 文件后才会启动服务器。项目越大，启动和热更新越慢。
* **Vite**：基于**ESM** 和 **原生 ES 模块**。在开发环境下，它不打包代码，而是直接启动一个服务器。浏览器按需请求模块，Vite 服务器按需编译并提供它们。**快的原因**：
  1. **无需打包**：消除了打包器的编译成本。
  2. **按需编译**：只编译当前屏幕上实际需要的代码。
  3. **利用浏览器缓存**：依赖模块（如 npm 包）使用强缓存，源码模块使用协商缓存。

**11. Vite 通过什么编译？**

* 在生产环境下，Vite 使用 **Rollup** 进行打包，因为它更高效和简洁。
* 在开发环境下，Vite 本身充当了一个**按需编译的服务器**，它使用 **esbuild** 进行依赖预构建和 TS/JSX 的转换，因为 esbuild 用 Go 编写，编译速度极快。

**12. Webpack 有使用过吗？**
（根据你的实际情况回答）是的，在之前的项目/学习中用过。了解其核心概念：**入口、输出、Loader、插件**。Loader 用于转换特定类型的模块（如将 Sass 转为 CSS），插件用于执行更广泛的任务（如打包优化、资源管理等）。

### **六、性能优化与网络**

**13. 实现图片懒加载方式？如何判断滚动到这个图片资源？**

* **方法**：将图片的 `src` 属性暂存到 `data-src` 等自定义属性中。当图片进入可视区域时，再将 `data-src` 的值赋给 `src`。
* **判断方式**：
  1. **传统方式**：监听 `scroll` 事件，使用 `Element.getBoundingClientRect()` 获取图片位置，与视口高度比较。需要节流优化。
  2. **现代方式**：使用 **`IntersectionObserver` API**（见下题）。

**14. 有了解过 IntersectionObserver 这个 API 吗？**
是的。它是一个现代的浏览器 API，可以**异步**监听目标元素与其祖先元素或视口交叉状态的变化。用它实现懒加载非常简单高效：

```javascript
const observer = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) { // 如果进入视口
      const img = entry.target;
      img.src = img.dataset.src; // 开始加载图片
      observer.unobserve(img); // 停止观察
    }
  });
});
// 对所有需要懒加载的图片调用 observer.observe(imgElement);
```

**15. HTTP 状态码 301、302**

* **301 Moved Permanently**：**永久重定向**。请求的资源已被永久移动到新位置。浏览器会缓存这个重定向，下次会直接访问新地址。
* **302 Found**：**临时重定向**。请求的资源临时从不同的位置响应。浏览器不会缓存，下次请求可能还会发往原地址。

### **七、数据请求与媒体处理**

**16. 前后端交互中，数据请求部分如何实现？用什么来发送请求？**
通常使用 JavaScript 提供的 `fetch` API 或第三方库（如 **`axios`**）来发送 HTTP 请求。我个人更常用 `axios`，因为它功能更强大，例如：提供了请求和响应拦截器、自动转换 JSON 数据、客户端支持防御 XSRF 等。

**17-19. 视频相关问题**
（这些问题非常专业，如果你不熟悉，可以坦诚说明。以下为简要答案）

* **17. 逐帧转换**：可以通过 HTML5 的 `<video>` 元素和 `<canvas>` 元素结合实现。将视频绘制到 Canvas 上，然后使用 `canvas.getContext('2d').getImageData()` 获取像素数据进行分析或处理。
* **18. FFmpeg**：是一个强大的开源音视频处理工具库，可以进行格式转换、剪辑、截图、添加水印等操作。通常在**后端**或**Node.js环境**下使用。
* **19. 视频帧与上传**：
  * **帧类型**：I帧（关键帧，完整图像）、P帧（向前预测帧，依赖前一帧）、B帧（双向预测帧，依赖前后帧）。
  * **上传过程**：前端将视频文件通过 HTTP `POST` 请求以 `multipart/form-data` 格式发送给后端接口。对于大文件，通常会进行**分片上传**和**断点续传**。

### **八、JavaScript & 浏览器存储**

**20. Promise 中有哪些方法？**

* **实例方法**：
  * `.then()`：处理成功状态。
  * `.catch()`：处理失败状态。
  * `.finally()`：无论成功失败都会执行。
* **静态方法**：
  * `Promise.all()`：全部成功才算成功，一个失败立即失败。
  * `Promise.race()`：竞速，第一个改变状态的 Promise 决定结果。
  * `Promise.allSettled()`：等待所有 Promise 完成（无论成功失败），返回结果数组。
  * `Promise.any()`：只要有一个成功就算成功，全部失败才失败。
  * `Promise.resolve()/reject()`：创建一個已成功/已失败的 Promise。

**21. localStorage**
是浏览器提供的一种本地存储机制，用于将数据**持久化**地存储在浏览器中，除非主动清除，否则数据不会过期。存储大小通常为 5MB，仅在客户端使用，不随 HTTP 请求发送到服务器。

### **九、CSS 布局与单位**

**22. 如何实现子元素水平垂直居中？**

* **Flexbox**：
  ```css
  .parent { display: flex; justify-content: center; align-items: center; }
  ```
* **Grid**：
  ```css
  .parent { display: grid; place-items: center; }
  ```
* **绝对定位 + transform**：
  ```css
  .child { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
  ```

**23. Grid 布局中 1fr 表示什么？**
`fr` 是**分数单位**。`1fr` 表示在容器剩余空间中所占的一份。例如 `grid-template-columns: 1fr 2fr;` 表示两列，第二列的宽度是第一列的两倍。

**24. rem, em 有什么区别？宽度设置 50vw 表示什么？**

* **rem**：相对于**根元素**的字体大小。
* **em**：相对于**父元素**的字体大小。
* **50vw**：表示视口宽度的 50%。

### **十、综合与学习**

**25. 页面加载优化方式有哪些？**

1. **资源优化**：压缩代码和图片，使用 Tree Shaking，代码分割，懒加载。
2. **网络优化**：利用浏览器缓存，使用 CDN，开启 Gzip 压缩。
3. **渲染优化**：CSS 放头部，JS 放底部或使用 `async/defer`，减少重排重绘。
4. **关键技术**：服务端渲染，预加载关键资源。

**26. 服务端渲染相比普通渲染的优势？**

* **更好的首屏加载性能**：服务器直接返回渲染好的 HTML，用户无需等待 JS 下载和执行就能看到内容。
* **更好的 SEO**：搜索引擎爬虫可以直接抓取已渲染的页面内容。

**27. 一周内学习新技术栈的规划？**

1. **目标定位**：明确学习目标和核心应用场景。
2. **官方文档**：花 1-2 天快速通读官方文档和指南，并动手写 Demo。
3. **项目实践**：用 3-4 天基于该技术做一个核心功能完整的小项目。
4. **查漏补缺**：最后 1-2 天回顾总结，查阅社区文章，解决项目中遇到的问题。
5. **总结输出**：通过写博客或笔记来巩固知识。

**28. 小程序了解过吗？**
（根据实际情况回答）是的，了解过。知道其开发类似于前端，但使用特定的标签和 API，逻辑层和渲染层分离，以及有一套自己的生命周期和发布流程。

**29. AI 开发工具，如何帮助学习？**
AI 工具可以作为强大的学习助手：

1. **个性化答疑**：随时解答疑惑，提供代码示例。
2. **代码审查与优化**：分析代码，提出改进建议。
3. **生成学习路径**：根据目标生成定制化的学习大纲。
4. **模拟面试**：进行技术面试练习。

![1760766782063](image/面试题/1760766782063.png)

---



好的，这是后续问题的详细解答，同样以清晰、准确为目标，方便你面试时使用。

---

### **三、网络协议**

**3. 项目中有使用 WebSocket，说说 HTTP 和 WebSocket 的不同**

| 特性               | HTTP                                                                | WebSocket                                                                      |
| :----------------- | :------------------------------------------------------------------ | :----------------------------------------------------------------------------- |
| **通信模式** | **请求-响应**模式。客户端发起请求，服务器返回响应后连接关闭。 | **全双工通信**模式。建立连接后，双方可以随时主动向对方发送数据。         |
| **连接状态** | **无状态**。每个请求都是独立的，服务器不记录状态。            | **有状态**。建立一次连接后，连接会保持，直到一方主动关闭。               |
| **协议开销** | 每次请求都包含完整的**请求头/响应头**，开销较大。             | 建立连接时通过 HTTP 握手，之后数据传输**头部开销极小**。                 |
| **适用场景** | 获取网页、提交表单等**短连接、一次性**的数据交互。            | 实时聊天、实时游戏、股票行情、协同编辑等需要**长连接、高实时性**的场景。 |

**核心区别**：HTTP 像**发邮件**，一来一回；WebSocket 像**打电话**，接通后可以持续对话。

**4. 详细说说 TCP 三次握手和四次挥手**

**三次握手 - 建立连接（保证双方都有发送和接收的能力）**

1. **第一次**：客户端发送 `SYN=1` 和随机序列号 `seq=x` 给服务器。客户端进入 `SYN_SENT` 状态。
2. **第二次**：服务器收到后，回复 `SYN=1`, `ACK=1`，确认号 `ack=x+1`，以及自己的随机序列号 `seq=y`。服务器进入 `SYN_RCVD` 状态。
3. **第三次**：客户端收到后，再发送 `ACK=1`，确认号 `ack=y+1`, `seq=x+1`。服务器收到后，双方进入 `ESTABLISHED` 状态，连接建立。

**四次挥手 - 终止连接（双方都要确认数据已发送完毕）**

1. **第一次**：客户端（主动关闭方）发送 `FIN=1` 和序列号 `seq=u`。客户端进入 `FIN_WAIT_1` 状态。
2. **第二次**：服务器收到 `FIN` 后，发送 `ACK=1`, 确认号 `ack=u+1`, 序列号 `seq=v`。服务器进入 `CLOSE_WAIT` 状态。客户端收到后进入 `FIN_WAIT_2` 状态。
   *（此时，从客户端到服务器的连接关闭，但服务器可能还有数据要发送给客户端）*
3. **第三次**：服务器发送完所有数据后，发送 `FIN=1`, `ACK=1`, 确认号 `ack=u+1`, 序列号 `seq=w`。服务器进入 `LAST_ACK` 状态。
4. **第四次**：客户端收到后，发送 `ACK=1`, 确认号 `ack=w+1`, 序列号 `seq=u+1`。客户端进入 `TIME_WAIT` 状态，等待 `2MSL` 后关闭。服务器收到 `ACK` 后立即关闭。

---

### **五、CSS 深入**

**5. 谈谈 CSS 的盒模型**
CSS 盒模型规定了一个元素所占用的总空间，由内容、内边距、边框和外边距组成。

* **标准盒模型**：
  * `width` 和 `height` 属性只指**内容区域**的宽高。
  * 元素总宽度 = `width` + `padding` + `border` + `margin`
* **IE盒模型**：
  * `width` 和 `height` 属性包含了**内容、内边距和边框**。
  * 元素总宽度 = `width` + `margin`
* **控制**：可以通过 `box-sizing` 属性切换。`content-box`（标准） / `border-box`（IE）。

**6. CSS 有哪些水平垂直居中的方式**

* **Flexbox**：`display: flex; justify-content: center; align-items: center;`
* **Grid**：`display: grid; place-items: center;`
* **绝对定位 + Transform**：`position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);`
* **绝对定位 + Margin**：`position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto;`（需定宽高）

**7. 你谈到了 flex 布局，flex 布局如何实现换行**
使用 `flex-wrap` 属性。

* `flex-wrap: nowrap;`（默认，不换行）
* `flex-wrap: wrap;`（换行，第一行在上方）
* `flex-wrap: wrap-reverse;`（换行，第一行在下方）

---

### **六、JavaScript 核心**

**8. JS 都有哪些数据类型？**

* **基本数据类型**：`Undefined`, `Null`, `Boolean`, `Number`, `String`, `BigInt`, `Symbol`
* **引用数据类型**：`Object`（包括 `Array`, `Function`, `Date` 等）

**9. 基本数据类型和引用数据类型有什么不同吗？**

* **存储位置**：基本数据类型的数据直接存储在**栈**中；引用数据类型的地址存储在**栈**中，实际数据存储在**堆**中。
* **复制行为**：复制基本数据类型，是**值的拷贝**，互不影响。复制引用数据类型，是**地址的拷贝**，两个变量指向同一个对象，会相互影响。
* **比较方式**：基本数据类型比较**值**是否相等。引用数据类型比较**内存地址**是否相同。

**10. 有没有听过深拷贝和浅拷贝**

* **浅拷贝**：只复制对象的第一层属性。如果属性是引用类型，则复制其地址。例如 `Object.assign()`, 展开运算符 `...`。
* **深拷贝**：完全复制一个对象，包括它里面所有层级的引用类型属性，创建一个完全独立的新对象。例如 `JSON.parse(JSON.stringify(obj))`（有局限性），或使用工具库 `lodash.cloneDeep`。

---

### **七、React 与算法**

**11. React 里面 Key 的作用是什么？**
`key` 是 React 用于**识别列表中哪些元素被改变、添加或删除**的唯一标识。当列表数据变化时，React 会使用 `key` 来进行高效的 **Diff 算法**对比，从而最小化 DOM 操作，提升性能。

**12. 虚拟 DOM 是什么？**
虚拟 DOM 是一个**轻量的 JavaScript 对象**，它是真实 DOM 的抽象表示。当状态变化时，React 会先计算出新的虚拟 DOM，然后通过 **Diff 算法** 与旧的虚拟 DOM 进行比较，找出最小差异，最后**批量、高效地**将这些差异更新到真实 DOM 上。这避免了直接操作真实 DOM 带来的性能损耗。

**13. 现写一个将一维数组变成二维数组的函数**

```javascript
function chunkArray(arr, chunkSize) {
  const result = [];
  for (let i = 0; i < arr.length; i += chunkSize) {
    // 从原数组中截取 chunkSize 长度的片段，并推入结果数组
    result.push(arr.slice(i, i + chunkSize));
  }
  return result;
}

// 测试
const input = [1, 2, 3, 4, 5];
console.log(chunkArray(input, 2)); // 输出：[[1,2], [3,4], [5]]
```

**核心思路**：使用 `for` 循环，以 `chunkSize` 为步长遍历原数组，在每次循环中使用 `Array.prototype.slice` 方法截取相应长度的子数组并放入新数组。
